// Copyright 2017 Capsule8, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package perf

import (
	"bytes"
	"encoding/hex"
	"testing"
)

//
// TestPack tests the creation of perf_event_attr structs to be passed to
// the kernel. Expected byte slices are generated from creating the
// test struct values in C.
//
func TestPack(t *testing.T) {
	expected := []byte{
		0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x62, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	expected2 := []byte{
		0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
		0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	ea := &EventAttr{}
	ea.SampleType = PERF_SAMPLE_TIME | PERF_SAMPLE_CPU
	ea.SamplePeriod = 1

	ea.Watermark = true
	ea.WakeupWatermark = 1

	ea.SampleIDAll = true
	ea.Comm = true
	ea.CommExec = true
	ea.Task = true

	buf := new(bytes.Buffer)
	err := ea.write(buf)
	if err != nil {
		t.Fatal(err)
	}
	b := buf.Bytes()

	if len(b) != len(expected) {
		t.Fatalf("Packed length does not match expected: %d vs. %d", len(b), len(expected))
	}

	if bytes.Compare(b, expected) != 0 {
		t.Fatal("Packed contents do not match expected")
	}

	ea = &EventAttr{}
	ea.Type = PERF_TYPE_TRACEPOINT
	ea.SampleType = PERF_SAMPLE_RAW
	ea.SamplePeriod = 1
	ea.WakeupEvents = 1
	ea.Config = 120

	buf.Reset()
	err = ea.write(buf)
	if err != nil {
		t.Fatal(err)
	}
	b = buf.Bytes()

	if len(b) != len(expected2) {
		t.Fatalf("Packed length does not match expected: %d vs. %d", len(b), len(expected))
	}

	if bytes.Compare(b, expected2) != 0 {
		t.Fatal("Packed contents do not match expected:\n", hex.Dump(b), hex.Dump(expected2))
	}

}
